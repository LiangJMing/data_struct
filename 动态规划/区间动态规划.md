### 区间动态规划

> 特点：
>
> 大区间包含小区间
>
> 状态转移从小区间推到大区间
>
> dp时，遍历起点和区间长度len
>
> 如：
>
> for(int len = 1;len<=n;++len){
>
> ​	for(int i=1,j = i+len;j<=n;++i,++j)
>
> ​			.....
>
> }



> 洛谷题目
>
> 合唱队https://www.luogu.com.cn/problem/P3205
>
> 规定排列方式和目标队列，求一共有多少中方式能排到这样的队列



###### 思路

> 划分状态
>
> $f[i][j]$表示排成目标队列$从a[i]到a[j]$的方法数
>
> 新进入的人可以在最右边或者最左边
>
> 再升一维
>
> $f[i][j][0]$表示排成目标队列$从a[i]到a[j]$新进元素在最左边的方法数
>
> $f[i][j][1]$表示排成目标队列$从a[i]到a[j]$新进元素在最右边的方法数
>
> 找上一状态
>
> 1. 新进元素在最左边  即是a[i]
>
>    同时说明它前面的元素比她小，这个元素在那里呢
>
>    可以在a[i+1],也可以在a[j]     
>
>    在a[i+1] 说明元素从左边进的 这个状态表示为$f[i-1][i][0]$
>
>    在a[j] 说明元素从右边进的 这个状态表示为$f[i-1][i][1]$
>
> 2. 新进元素在最右边  即是a[j]
>
>    同时说明它前面的元素比她大 ，这个元素在那里呢
>
>    可以在a[i],也可以在a[j-1]  
>
>    在a[i] 说明元素从左边进的 这个状态表示为$f[i][j-1][0]$
>
>    在a[j-1] 说明元素从右边进的 这个状态表示为$f[i][j-1][1]$
>
> 
>
> 得状态转移方程

~~~c++
//新进元素在最左边，是a[i]
if (a[i] < a[i + 1])   //它的前一个元素被放在哪里了呢，a[i+1]
    f[i][j][0] += f[i + 1][j][0];
if (a[i] < a[j])     //或者a[j]
    f[i][j][0] += f[i + 1][j][1];
//新进元素在最左边，是a[j]
if (a[j] > a[i]) 
    f[i][j][1] += f[i][j-1][0];
if (a[j] > a[j-1]) 
    f[i][j][1] += f[i][j-1][1];
~~~



完整代码

~~~c++
#include <iostream>
#include <algorithm>
#include <stdio.h>
#include <string>


using namespace std;

int f[2010][2010][2], a[2010];

int main() {

	//input
	int n;
	cin >> n;

	for (int i = 1;i <= n;++i) {
		cin >> a[i];
	}


	//init
	for (int i = 1;i <= n;++i) {
		f[i][i][0] = 1;
	}
	

	//dp
	for(int len=1;len<=n;len++)
		for (int i = 1, j = i + len;j <= n;++i, ++j) {
			if (a[i] < a[i + 1]) f[i][j][0] += f[i + 1][j][0];
			if (a[i] < a[j]) f[i][j][0] += f[i + 1][j][1];
			if (a[j] > a[i]) f[i][j][1] += f[i][j-1][0];
			if (a[j] > a[j-1]) f[i][j][1] += f[i][j-1][1];
			f[i][j][0] %= 19650827;
			f[i][j][1] %= 19650827;
		}


	//output
	cout << (f[1][n][0] + f[1][n][1]) % 19650827;
	

	return 0;
}
~~~



